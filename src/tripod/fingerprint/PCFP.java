package tripod.fingerprint;

/***********************************************************************
			 PUBLIC DOMAIN NOTICE
		     NIH Chemical Genomics Center
         National Center for Advancing Translational Sciences

This software/database is a "United States Government Work" under the
terms of the United States Copyright Act.  It was written as part of
the author's official duties as United States Government employee and
thus cannot be copyrighted.  This software/database is freely
available to the public for use. The NIH Chemical Genomics Center
(NCGC) and the U.S. Government have not placed any restriction on its
use or reproduction. 

Although all reasonable efforts have been taken to ensure the accuracy
and reliability of the software and data, the NCGC and the U.S.
Government do not and cannot warrant the performance or results that
may be obtained by using this software or data. The NCGC and the U.S.
Government disclaim all warranties, express or implied, including
warranties of performance, merchantability or fitness for any
particular purpose.

Please cite the authors in any work or product based on this material.

************************************************************************/

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;
import java.util.BitSet;
import java.util.logging.Logger;
import java.util.logging.Level;

import chemaxon.struc.MolAtom;
import chemaxon.struc.MolBond;
import chemaxon.struc.Molecule;
import chemaxon.util.MolHandler;

import tripod.search.SearchService2;
import tripod.search.SearchCallback;
import tripod.search.SearchParams;

import tripod.util.Base64;
import tripod.chem.RingPerception;

/**
 * Implementation of PubChem's structural keys 881-bit fingerprint based on
 * the following spec
 * ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.txt
 */
public class PCFP extends SearchService2 
    implements SearchCallback<SearchService2.MolEntry> {
    static final Logger logger = Logger.getLogger(PCFP.class.getName());
    static final private long serialVersionUID = 0x39ef2486e3aa3520l;

    // starting at bit 263...
    static final String[] PATTERNS = new String[] {
	/**
         * Section 3: Simple atom pairs. These bits test for the presence 
         * of patterns of bonded atom pairs, regardless of bond order or 
         * count.
         */
	/*263*/ "[Li]~[H]",
	/*264*/ "[Li]~[Li]",
	/*265*/ "[Li]~[B]",
	/*266*/ "[Li]~[#6]",
	/*267*/ "[Li]~[#8]",
	/*268*/ "[Li]~[F]",
	/*269*/ "[Li]~[#15]",
	/*270*/ "[Li]~[#16]",
	/*271*/ "[Li]~[Cl]",
	/*272*/ "[#5]~[H]",
	/*273*/ "[#5]~[#5]",
	/*274*/ "[#5]~[#6]",
	/*275*/ "[#5]~[#7]",
	/*276*/ "[#5]~[#8]",
	/*277*/ "[#5]~[F]",
	/*278*/ "[#5]~[Si]",
	/*279*/ "[#5]~[#15]",
	/*280*/ "[#5]~[#16]",
	/*281*/ "[#5]~[Cl]",
	/*282*/ "[#5]~[Br]",
	/*283*/ "[#6]~[H]",
	/*284*/ "[#6]~[#6]",
	/*285*/ "[#6]~[#7]",
	/*286*/ "[#6]~[#8]",
	/*287*/ "[#6]~[F]",
	/*288*/ "[#6]~[Na]",
	/*289*/ "[#6]~[Mg]",
	/*290*/ "[#6]~[Al]",
	/*291*/ "[#6]~[Si]",
	/*292*/ "[#6]~[#15]",
	/*293*/ "[#6]~[#16]",
	/*294*/ "[#6]~[Cl]",
	/*295*/ "[#6]~[As]",
	/*296*/ "[#6]~[Se]",
	/*297*/ "[#6]~[Br]",
	/*298*/ "[#6]~[I]",
	/*299*/ "[#7]~[H]",
	/*300*/ "[#7]~[#7]",
	/*301*/ "[#7]~[#8]",
	/*302*/ "[#7]~[F]",
	/*303*/ "[#7]~[Si]",
	/*304*/ "[#7]~[#15]",
	/*305*/ "[#7]~[#16]",
	/*306*/ "[#7]~[Cl]",
	/*307*/ "[#7]~[Br]",
	/*308*/ "[#8]~[H]",
	/*309*/ "[#8]~[#8]",
	/*310*/ "[#8]~[Mg]",
	/*311*/ "[#8]~[Na]",
	/*312*/ "[#8]~[Al]",
	/*313*/ "[#8]~[Si]",
	/*314*/ "[#8]~[#15]",
	/*315*/ "[#8]~[K]",
	/*316*/ "[F]~[#15]",
	/*317*/ "[F]~[#16]",
	/*318*/ "[Al]~[H]",
	/*319*/ "[Al]~[Cl]",
	/*320*/ "[Si]~[H]",
	/*321*/ "[Si]~[Si]",
	/*322*/ "[Si]~[Cl]",
	/*323*/ "[#15]~[H]",
	/*324*/ "[#15]~[#15]",
	/*325*/ "[As]~[H]",
	/*326*/ "[As]~[As]",

	/**
         * Section 4: Simple atom nearest neighbors.  These bits test for the 
         * presence of atom nearest neighbor patterns, regardless of 
         * bond order or count, but where bond aromaticity (denoted by 
         * "~") is significant.
         */
	/*327*/ "[#6](~Br)(~[#6])",
	/*328*/ "[#6](~Br)(~[#6])(~[#6])",
	/*329*/ "[#6](~[Br])([H])",
	/*330*/ "[#6](~[Br])(:[c])",
	/*331*/ "[#6](~[Br])(:[n])",
	/*332*/ "[#6](~[#6])(~[#6])",
	/*333*/ "[#6](~[#6])(~[#6])(~[#6])",
	/*334*/ "[#6](~[#6])(~[#6])(~[#6])(~[#6])",
	/*335*/ "[#6](~[#6])(~[#6])(~[#6])([H])",
	/*336*/ "[#6](~[#6])(~[#6])(~[#6])(~[#7])",
	/*337*/ "[#6](~[#6])(~[#6])(~[#6])(~[#8])",
	/*338*/ "[#6](~[#6])(~[#6])([H])(~[#7])",
	/*339*/ "[#6](~[#6])(~[#6])([H])(~[#8])",
	/*340*/ "[#6](~[#6])(~[#6])(~[#7])",
	/*341*/ "[#6](~[#6])(~[#6])(~[#8])",
	/*342*/ "[#6](~[#6])(~[Cl])",
	/*343*/ "[#6](~[#6])(~[Cl])([H])",
	/*344*/ "[#6](~[#6])([H])",
	/*345*/ "[#6](~[#6])([H])(~[#7])",
	/*346*/ "[#6](~[#6])([H])(~[#8])",
	/*347*/ "[#6](~[#6])([H])(~[#8])(~[#8])",
	/*348*/ "[#6](~[#6])([H])(~[#15])",
	/*349*/ "[#6](~[#6])([H])(~[#16])",
	/*350*/ "[#6](~[#6])(~[I])",
	/*351*/ "[#6](~[#6])(~[#7])",
	/*352*/ "[#6](~[#6])(~[#8])",
	/*353*/ "[#6](~[#6])(~[#16])",
	/*354*/ "[#6](~[#6])(~[Si])",
	/*355*/ "[#6](~[#6])(:c)",
	/*356*/ "[#6](~[#6])(:c)(:c)",
	/*357*/ "[#6](~[#6])(:c)(:n)",
	/*358*/ "[#6](~[#6])(:n)",
	/*359*/ "[#6](~[#6])(:n)(:n)",
	/*360*/ "[#6](~[Cl])(~[Cl])",
	/*361*/ "[#6](~[Cl])([H])",
	/*362*/ "[#6](~[Cl])(:c)",
	/*363*/ "[#6](~[F])(~[F])",
	/*364*/ "[#6](~[F])(:c)",
	/*365*/ "[#6]([H])(~[#7])",
	/*366*/ "[#6]([H])(~[#8])",
	/*367*/ "[#6]([H])(~[#8])(~[#8])",
	/*368*/ "[#6]([H])(~[#16])",
	/*369*/ "[#6]([H])(~[Si])",
	/*370*/ "[#6]([H])(:c)",
	/*371*/ "[#6]([H])(:c)(:c)",
	/*372*/ "[#6]([H])(:c)(:n)",
	/*373*/ "[#6]([H])(:n)",
	/*374*/ "[#6]([H])([H])([H])",
	/*375*/ "[#6](~[#7])(~[#7])",
	/*376*/ "[#6](~[#7])(:c)",
	/*377*/ "[#6](~[#7])(:c)(:c)",
	/*378*/ "[#6](~[#7])(:c)(:n)",
	/*379*/ "[#6](~[#7])(:n)",
	/*380*/ "[#6](~[#8])(~[#8])",
	/*381*/ "[#6](~[#8])(:c)",
	/*382*/ "[#6](~[#8])(:c)(:c)",
	/*383*/ "[#6](~[#16])(:c)",
	/*384*/ "[#6](:c)(:c)",
	/*385*/ "[#6](:c)(:c)(:c)",
	/*386*/ "[#6](:c)(:c)(:n)",
	/*387*/ "[#6](:c)(:n)",
	/*388*/ "[#6](:c)(:n)(:n)",
	/*389*/ "[#6](:n)(:n)",
	/*390*/ "[#7](~[#6])(~[#6])",
	/*391*/ "[#7](~[#6])(~[#6])(~[#6])",
	/*392*/ "[#7](~[#6])(~[#6])([H])",
	/*393*/ "[#7](~[#6])([H])",
	/*394*/ "[#7](~[#6])([H])(~[#7])",
	/*395*/ "[#7](~[#6])(~[#8])",
	/*396*/ "[#7](~[#6])(:c)",
	/*397*/ "[#7](~[#6])(:c)(:c)",
	/*398*/ "[#7]([H])(~[#7])",
	/*399*/ "[#7]([H])(:c)",
	/*400*/ "[#7]([H])(:c)(:c)",
	/*401*/ "[#7](~[#8])(~[#8])",
	/*402*/ "[#7](~[#8])(:o)",
	/*403*/ "[#7](:c)(:c)",
	/*404*/ "[#7](:c)(:c)(:c)",
	/*405*/ "[#8](~[#6])(~[#6])",
	/*406*/ "[#8](~[#6])([H])",
	/*407*/ "[#8](~[#6])(~[#15])",
	/*408*/ "[#8]([H])(~[#16])",
	/*409*/ "[#8](:c)(:c)",
	/*410*/ "[#15](~[#6])(~[#6])",
	/*411*/ "[#15](~[#8])(~[#8])",
	/*412*/ "[#16](~[#6])(~[#6])",
	/*413*/ "[#16](~[#6])([H])",
	/*414*/ "[#16](~[#6])(~[#8])",
	/*415*/ "[Si](~[#6])(~[#6])",

	/**
	 * Section 5: Detailed atom neighborhoods - These bits test for the 
         * presence of detailed atom neighborhood patterns, regardless 
         * of count, but where bond orders are specific, bond 
         * aromaticity matches both single and double bonds, and where 
         * "-", "=", and "#" matches a single bond, double bond, and 
         * triple bond order, respectively.
         */
	/*416*/ "[#6]=,:[#6]",
	/*417*/ "[#6]#[#6]",
	/*418*/ "[#6]=,:[#7]",
	/*419*/ "[#6]#[#7]",
	/*420*/ "[#6]=,:[#8]",
	/*421*/ "[#6]=,:[#16]",
	/*422*/ "[#7]=,:[#7]",
	/*423*/ "[#7]=,:[#8]",
	/*424*/ "[#7]=,:[#15]",
	/*425*/ "[#15]=,:[#8]",
	/*426*/ "[#15]=,:[#15]",
	/*427*/ "[#6](#[#6])(-,:[#6])",
	/*428*/ "[#6](#[#6])([H])",
	/*429*/ "[#6](#[#7])(-,:[#6])",
	/*430*/ "[#6](-,:[#6])(-,:[#6])(=,:[#6])",
	/*431*/ "[#6](-,:[#6])(-,:[#6])(=,:[#7])",
	/*432*/ "[#6](-,:[#6])(-,:[#6])(=,:[#8])",
	/*433*/ "[#6](-,:[#6])([Cl])(=,:[#8])",
	/*434*/ "[#6](-,:[#6])([H])(=,:[#6])",
	/*435*/ "[#6](-,:[#6])([H])(=,:[#7])",
	/*436*/ "[#6](-,:[#6])([H])(=,:[#8])",
	/*437*/ "[#6](-,:[#6])(-,:[#7])(=,:[#6])",
	/*438*/ "[#6](-,:[#6])(-,:[#7])(=,:[#7])",
	/*439*/ "[#6](-,:[#6])(-,:[#7])(=,:[#8])",
	/*440*/ "[#6](-,:[#6])(-,:[#8])(=,:[#8])",
	/*441*/ "[#6](-,:[#6])(=,:[#6])",
	/*442*/ "[#6](-,:[#6])(=,:[#7])",
	/*443*/ "[#6](-,:[#6])(=,:[#8])",
	/*444*/ "[#6]([Cl])(=,:[#8])",
	/*445*/ "[#6]([H])(-,:[#7])(=,:[#6])",
	/*446*/ "[#6]([H])(=,:[#6])",
	/*447*/ "[#6]([H])(=,:[#7])",
	/*448*/ "[#6]([H])(=,:[#8])",
	/*449*/ "[#6](-,:[#7])(=,:[#6])",
	/*450*/ "[#6](-,:[#7])(=,:[#7])",
	/*451*/ "[#6](-,:[#7])(=,:[#8])",
	/*452*/ "[#6](-,:[#8])(=,:[#8])",
	/*453*/ "[#7](-,:[#6])(=,:[#6])",
	/*454*/ "[#7](-,:[#6])(=,:[#8])",
	/*455*/ "[#7](-,:[#8])(=,:[#8])",
	/*456*/ "[#15](-,:[#8])(=,:[#8])",
	/*457*/ "[#16](-,:[#6])(=,:[#8])",
	/*458*/ "[#16](-,:[#8])(=,:[#8])",
	/*459*/ "[#16](=,:[#8])(=,:[#8])",
        
	/**
	 * Section 6: Simple SMARTS patterns - These bits test for the presence 
         * of simple SMARTS patterns, regardless of count, but where 
         * bond orders are specific and bond aromaticity matches both 
         * single and double bonds.
         */
	/*460*/ "[#6]-,:[#6]-,:[#6]#[#6]",
	/*461*/ "[#8]-,:[#6]-,:[#6]=,:[#7]",
	/*462*/ "[#8]-,:[#6]-,:[#6]=,:[#8]",
	/*463*/ "[#7]:[#6]-,:[#16]-[#1]",
	/*464*/ "[#7]-,:[#6]-,:[#6]=,:[#6]",
	/*465*/ "[#8]=,:[#16]-,:[#6]-,:[#6]",
	/*466*/ "[#7]#[#6]-,:[#6]=,:[#6]",
	/*467*/ "[#6]=,:[#7]-,:[#7]-,:[#6]",
	/*468*/ "[#8]=,:[#16]-,:[#6]-,:[#7]",
	/*469*/ "[#16]-,:[#16]-,:[#6]:[#6]",
	/*470*/ "[#6]:[#6]-,:[#6]=,:[#6]",
	/*471*/ "[#16]:[#6]:[#6]:[#6]",
	/*472*/ "[#6]:[#7]:[#6]-,:[#6]",
	/*473*/ "[#16]-,:[#6]:[#7]:[#6]",
	/*474*/ "[#16]:[#6]:[#6]:[#7]",
	/*475*/ "[#16]-,:[#6]=,:[#7]-,:[#6]",
	/*476*/ "[#6]-,:[#8]-,:[#6]=,:[#6]",
	/*477*/ "[#7]-,:[#7]-,:[#6]:[#6]",
	/*478*/ "[#16]-,:[#6]=,:[#7]-,:[#1]",
	/*479*/ "[#16]-,:[#6]-,:[#16]-,:[#6]",
	/*480*/ "[#6]:[#16]:[#6]-,:[#6]",
	/*481*/ "[#8]-,:[#16]-,:[#6]:[#6]",
	/*482*/ "[#6]:[#7]-,:[#6]:[#6]",
	/*483*/ "[#7]-,:[#16]-,:[#6]:[#6]",
	/*484*/ "[#7]-,:[#6]:[#7]:[#6]",
	/*485*/ "[#7]:[#6]:[#6]:[#7]",
	/*486*/ "[#7]-,:[#6]:[#7]:[#7]",
	/*487*/ "[#7]-,:[#6]=,:[#7]-,:[#6]",
	/*488*/ "[#7]-,:[#6]=,:[#7]-,:[#1]",
	/*489*/ "[#7]-,:[#6]-,:[#16]-,:[#6]",
	/*490*/ "[#6]-,:[#6]-,:[#6]=,:[#6]",
	/*491*/ "[#6]-,:[#7]:[#6]-,:[#1]",
	/*492*/ "[#7]-,:[#6]:[#8]:[#6]",
	/*493*/ "[#8]=,:[#6]-,:[#6]:[#6]",
	/*494*/ "[#8]=,:[#6]-,:[#6]:[#7]",
	/*495*/ "[#6]-,:[#7]-,:[#6]:[#6]",
	/*496*/ "[#7]:[#7]-,:[#6]-,:[#1]",
	/*497*/ "[#8]-,:[#6]:[#6]:[#7]",
	/*498*/ "[#8]-,:[#6]=,:[#6]-,:[#6]",
	/*499*/ "[#7]-,:[#6]:[#6]:[#7]",
	/*500*/ "[#6]-,:[#16]-,:[#6]:[#6]",
	/*501*/ "[Cl]-,:[#6]:[#6]-,:[#6]",
	/*502*/ "[#7]-,:[#6]=,:[#6]-,:[#1]",
	/*503*/ "[Cl]-,:[#6]:[#6]-,:[#1]",
	/*504*/ "[#7]:[#6]:[#7]-,:[#6]",
	/*505*/ "[Cl]-,:[#6]:[#6]-,:[#8]",
	/*506*/ "[#6]-,:[#6]:[#7]:[#6]",
	/*507*/ "[#6]-,:[#6]-,:[#16]-,:[#6]",
	/*508*/ "[#16]=,:[#6]-,:[#7]-,:[#6]",
	/*509*/ "[Br]-,:[#6]:[#6]-,:[#6]",
	/*510*/ "[#1]-,:[#7]-,:[#7]-,:[#1]",
	/*511*/ "[#16]=,:[#6]-,:[#7]-,:[#1]",
	/*512*/ "[#6]-,:[As]-[#8]-,:[#1]",
	/*513*/ "[#16]:[#6]:[#6]-,:[#1]",
	/*514*/ "[#8]-,:[#7]-,:[#6]-,:[#6]",
	/*515*/ "[#7]-,:[#7]-,:[#6]-,:[#6]",
	/*516*/ "[#1]-,:[#6]=,:[#6]-,:[#1]",
	/*517*/ "[#7]-,:[#7]-,:[#6]-,:[#7]",
	/*518*/ "[#8]=,:[#6]-,:[#7]-,:[#7]",
	/*519*/ "[#7]=,:[#6]-,:[#7]-,:[#6]",
	/*520*/ "[#6]=,:[#6]-,:[#6]:[#6]",
	/*521*/ "[#6]:[#7]-,:[#6]-,:[#1]",
	/*522*/ "[#6]-,:[#7]-,:[#7]-,:[#1]",
	/*523*/ "[#7]:[#6]:[#6]-,:[#6]",
	/*524*/ "[#6]-,:[#6]=,:[#6]-,:[#6]",
	/*525*/ "[As]-,:[#6]:[#6]-,:[#1]",
	/*526*/ "[Cl]-,:[#6]:[#6]-,:[Cl]",
	/*527*/ "[#6]:[#6]:[#7]-,:[#1]",
	/*528*/ "[#1]-,:[#7]-,:[#6]-,:[#1]",
	/*529*/ "[Cl]-,:[#6]-,:[#6]-,:[Cl]",
	/*530*/ "[#7]:[#6]-,:[#6]:[#6]",
	/*531*/ "[#16]-,:[#6]:[#6]-,:[#6]",
	/*532*/ "[#16]-,:[#6]:[#6]-,:[#1]",
	/*533*/ "[#16]-,:[#6]:[#6]-,:[#7]",
	/*534*/ "[#16]-,:[#6]:[#6]-,:[#8]",
	/*535*/ "[#8]=,:[#6]-,:[#6]-,:[#6]",
	/*536*/ "[#8]=,:[#6]-,:[#6]-,:[#7]",
	/*537*/ "[#8]=,:[#6]-,:[#6]-,:[#8]",
	/*538*/ "[#7]=,:[#6]-,:[#6]-,:[#6]",
	/*539*/ "[#7]=,:[#6]-,:[#6]-,:[#1]",
	/*540*/ "[#6]-,:[#7]-,:[#6]-,:[#1]",
	/*541*/ "[#8]-,:[#6]:[#6]-,:[#6]",
	/*542*/ "[#8]-,:[#6]:[#6]-,:[#1]",
	/*543*/ "[#8]-,:[#6]:[#6]-,:[#7]",
	/*544*/ "[#8]-,:[#6]:[#6]-,:[#8]",
	/*545*/ "[#7]-,:[#6]:[#6]-,:[#6]",
	/*546*/ "[#7]-,:[#6]:[#6]-,:[#1]",
	/*547*/ "[#7]-,:[#6]:[#6]-,:[#7]",
	/*548*/ "[#8]-,:[#6]-,:[#6]:[#6]",
	/*549*/ "[#7]-,:[#6]-,:[#6]:[#6]",
	/*550*/ "[Cl]-,:[#6]-,:[#6]-,:[#6]",
	/*551*/ "[Cl]-,:[#6]-,:[#6]-,:[#8]",
	/*552*/ "[#6]:[#6]-,:[#6]:[#6]",
	/*553*/ "[#8]=,:[#6]-,:[#6]=,:[#6]",
	/*554*/ "[Br]-,:[#6]-,:[#6]-,:[#6]",
	/*555*/ "[#7]=,:[#6]-,:[#6]=,:[#6]",
	/*556*/ "[#6]=,:[#6]-,:[#6]-,:[#6]",
	/*557*/ "[#7]:[#6]-,:[#8]-,:[#1]",
	/*558*/ "[#8]-,=,:[#7]-,:c:c",
	/*559*/ "[#8]-,:[#6]-,:[#7]-,:[#1]",
	/*560*/ "[#7]-,:[#6]-,:[#7]-,:[#6]",
	/*561*/ "[Cl]-,:[#6]-,:[#6]=,:[#8]",
	/*562*/ "[Br]-,:[#6]-,:[#6]=,:[#8]",
	/*563*/ "[#8]-,:[#6]-,:[#8]-,:[#6]",
	/*564*/ "[#6]=,:[#6]-,:[#6]=,:[#6]",
	/*565*/ "[#6]:[#6]-,:[#8]-,:[#6]",
	/*566*/ "[#8]-,:[#6]-,:[#6]-,:[#7]",
	/*567*/ "[#8]-,:[#6]-,:[#6]-,:[#8]",
	/*568*/ "N#[#6]-,:[#6]-,:[#6]",
	/*569*/ "[#7]-,:[#6]-,:[#6]-,:[#7]",
	/*570*/ "[#6]:[#6]-,:[#6]-,:[#6]",
	/*571*/ "[#1]-[#6]-,:[#8]-,:[#1]",
	/*572*/ "n:c:n:c",
	/*573*/ "[#8]-,:[#6]-,:[#6]=,:[#6]",
	/*574*/ "[#8]-,:[#6]-,:[#6]:[#6]-,:[#6]",
	/*575*/ "[#8]-,:[#6]-,:[#6]:[#6]-,:[#8]",
	/*576*/ "[#7]=,:[#6]-,:[#6]:[#6]-,:[#1]",
	/*577*/ "c:c-,:[#7]-,:c:c",
	/*578*/ "[#6]-,:[#6]:[#6]-,:c:c",
	/*579*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*580*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#7]",
	/*581*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#8]",
	/*582*/ "[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*583*/ "[Cl]-,:[#6]:[#6]-,:[#8]-,:[#6]",
	/*584*/ "c:c-,:[#6]=,:[#6]-,:[#6]",
	/*585*/ "[#6]-,:[#6]:[#6]-,:[#7]-,:[#6]",
	/*586*/ "[#6]-,:[#16]-,:[#6]-,:[#6]-,:[#6]",
	/*587*/ "[#7]-,:[#6]:[#6]-,:[#8]-,:[#1]",
	/*588*/ "[#8]=,:[#6]-,:[#6]-,:[#6]=,:[#8]",
	/*589*/ "[#6]-,:[#6]:[#6]-,:[#8]-,:[#6]",
	/*590*/ "[#6]-,:[#6]:[#6]-,:[#8]-,:[#1]",
	/*591*/ "[Cl]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*592*/ "[#7]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*593*/ "[#7]-,:[#6]-,:[#6]-,:[#6]-,:[#7]",
	/*594*/ "[#6]-,:[#8]-,:[#6]-,:[#6]=,:[#6]",
	/*595*/ "c:c-,:[#6]-,:[#6]-,:[#6]",
	/*596*/ "[#7]=,:[#6]-,:[#7]-,:[#6]-,:[#6]",
	/*597*/ "[#8]=,:[#6]-,:[#6]-,:c:c",
	/*598*/ "[Cl]-,:[#6]:[#6]:[#6]-,:[#6]",
	/*599*/ "[#1]-,:[#6]-,:[#6]=,:[#6]-,:[#1]",
	/*600*/ "[#7]-,:[#6]:[#6]:[#6]-,:[#6]",
	/*601*/ "[#7]-,:[#6]:[#6]:[#6]-,:[#7]",
	/*602*/ "[#8]=,:[#6]-,:[#6]-,:[#7]-,:[#6]",
	/*603*/ "[#6]-,:c:c:[#6]-,:[#6]",
	/*604*/ "[#6]-,:[#8]-,:[#6]-,:[#6]:c",
	/*605*/ "[#8]=,:[#6]-,:[#6]-,:[#8]-,:[#6]",
	/*606*/ "[#8]-,:[#6]:[#6]-,:[#6]-,:[#6]",
	/*607*/ "[#7]-,:[#6]-,:[#6]-,:[#6]:c",
	/*608*/ "[#6]-,:[#6]-,:[#6]-,:[#6]:c",
	/*609*/ "[Cl]-,:[#6]-,:[#6]-,:[#7]-,:[#6]",
	/*610*/ "[#6]-,:[#8]-,:[#6]-,:[#8]-,:[#6]",
	/*611*/ "[#7]-,:[#6]-,:[#6]-,:[#7]-,:[#6]",
	/*612*/ "[#7]-,:[#6]-,:[#8]-,:[#6]-,:[#6]",
	/*613*/ "[#6]-,:[#7]-,:[#6]-,:[#6]-,:[#6]",
	/*614*/ "[#6]-,:[#6]-,:[#8]-,:[#6]-,:[#6]",
	/*615*/ "[#7]-,:[#6]-,:[#6]-,:[#8]-,:[#6]",
	/*616*/ "c:c:n:n:c",
	/*617*/ "[#6]-,:[#6]-,:[#6]-,:[#8]-,:[#1]",
	/*618*/ "c:[#6]-,:[#6]-,:[#6]:c",
	/*619*/ "[#8]-,:[#6]-,:[#6]=,:[#6]-,:[#6]",
	/*620*/ "c:c-,:[#8]-,:[#6]-,:[#6]",
	/*621*/ "[#7]-,:[#6]:c:c:n",
	/*622*/ "[#8]=,:[#6]-,:[#8]-,:[#6]:c",
	/*623*/ "[#8]=,:[#6]-,:[#6]:[#6]-,:[#6]",
	/*624*/ "[#8]=,:[#6]-,:[#6]:[#6]-,:[#7]",
	/*625*/ "[#8]=,:[#6]-,:[#6]:[#6]-,:[#8]",
	/*626*/ "[#6]-,:[#8]-,:[#6]:[#6]-,:[#6]",
	/*627*/ "[#8]=,:[As]-,:[#6]:c:c",
	/*628*/ "[#6]-,:[#7]-,:[#6]-,:[#6]:c",
	/*629*/ "[#16]-,:[#6]:c:c-,:[#7]",
	/*630*/ "[#8]-,:[#6]:[#6]-,:[#8]-,:[#6]",
	/*631*/ "[#8]-,:[#6]:[#6]-,:[#8]-,:[#1]",
	/*632*/ "[#6]-,:[#6]-,:[#8]-,:[#6]:c",
	/*633*/ "[#7]-,:[#6]-,:[#6]:[#6]-,:[#6]",
	/*634*/ "[#6]-,:[#6]-,:[#6]:[#6]-,:[#6]",
	/*635*/ "[#7]-,:[#7]-,:[#6]-,:[#7]-[#1]",
	/*636*/ "[#6]-,:[#7]-,:[#6]-,:[#7]-,:[#6]",
	/*637*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*638*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#7]",
	/*639*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#8]",
	/*640*/ "[#6]=,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*641*/ "[#8]-,:[#6]-,:[#6]-,:[#6]=,:[#6]",
	/*642*/ "[#8]-,:[#6]-,:[#6]-,:[#6]=,:[#8]",
	/*643*/ "[#1]-[#6]-,:[#6]-,:[#7]-,:[#1]",
	/*644*/ "[#6]-,:[#6]=,:[#7]-,:[#7]-,:[#6]",
	/*645*/ "[#8]=,:[#6]-,:[#7]-,:[#6]-,:[#6]",
	/*646*/ "[#8]=,:[#6]-,:[#7]-,:[#6]-,:[#1]",
	/*647*/ "[#8]=,:[#6]-,:[#7]-,:[#6]-,:[#7]",
	/*648*/ "[#8]-,=,:[#7]-,:[#6]:[#6]-,:[#7]",
	/*649*/ "[#8]=,:[#7]-,:c:c-,:[#8]",
	/*650*/ "[#8]=,:[#6]-,:[#7]-,:[#6]=,:[#8]",
	/*651*/ "[#8]-,:[#6]:[#6]:[#6]-,:[#6]",
	/*652*/ "[#8]-,:[#6]:[#6]:[#6]-,:[#7]",
	/*653*/ "[#8]-,:[#6]:[#6]:[#6]-,:[#8]",
	/*654*/ "[#7]-,:[#6]-,:[#7]-,:[#6]-,:[#6]",
	/*655*/ "[#8]-,:[#6]-,:[#6]-,:[#6]:c",
	/*656*/ "[#6]-,:[#6]-,:[#7]-,:[#6]-,:[#6]",
	/*657*/ "[#6]-,:[#7]-,:[#6]:[#6]-,:[#6]",
	/*658*/ "[#6]-,:[#6]-,:[#16]-,:[#6]-,:[#6]",
	/*659*/ "[#8]-,:[#6]-,:[#6]-,:[#7]-,:[#6]",
	/*660*/ "[#6]-,:[#6]=,:[#6]-,:[#6]-,:[#6]",
	/*661*/ "[#8]-,:[#6]-,:[#8]-,:[#6]-,:[#6]",
	/*662*/ "[#8]-,:[#6]-,:[#6]-,:[#8]-,:[#6]",
	/*663*/ "[#8]-,:[#6]-,:[#6]-,:[#8]-,:[#1]",
	/*664*/ "[#6]-,:[#6]=,:[#6]-,:[#6]=,:[#6]",
	/*665*/ "[#7]-,:[#6]:[#6]-,:[#6]-,:[#6]",
	/*666*/ "[#6]=,:[#6]-,:[#6]-,:[#8]-,:[#6]",
	/*667*/ "[#6]=,:[#6]-,:[#6]-,:[#8]-,:[#1]",
	/*668*/ "[#6]-,:[#6]:[#6]-,:[#6]-,:[#6]",
	/*669*/ "[Cl]-,:[#6]:[#6]-,:[#6]=,:[#8]",
	/*670*/ "[Br]-,:[#6]:c:c-,:[#6]",
	/*671*/ "[#8]=,:[#6]-,:[#6]=,:[#6]-,:[#6]",
	/*672*/ "[#8]=,:[#6]-,:[#6]=,:[#6]-,:[#1]",
	/*673*/ "[#8]=,:[#6]-,:[#6]=,:[#6]-,:[#7]",
	/*674*/ "[#7]-,:[#6]-,:[#7]-,:[#6]:c",
	/*675*/ "[Br]-,:[#6]-,:[#6]-,:[#6]:c",
	/*676*/ "[#7]#[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*677*/ "[#6]-,:[#6]=,:[#6]-,:[#6]:c",
	/*678*/ "[#6]-,:[#6]-,:[#6]=,:[#6]-,:[#6]",
	/*679*/ "[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*680*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*681*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#8]",
	/*682*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#7]",
	/*683*/ "[#7]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*684*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*685*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#7]",
	/*686*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#8]",
	/*687*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]=,:[#8]",
	/*688*/ "[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*689*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*690*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#8]",
	/*691*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#7]",
	/*692*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*693*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#8]",
	/*694*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]=,:[#8]",
	/*695*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#7]",
	/*696*/ "[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*697*/ "[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6](-,:[#6])-,:[#6]",
	/*698*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*699*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6](-,:[#6])-,:[#6]",
	/*700*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#8]-,:[#6]",
	/*701*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6](-,:[#8])-,:[#6]",
	/*702*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#7]-,:[#6]",
	/*703*/ "[#8]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6](-,:[#7])-,:[#6]",
	/*704*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6]",
	/*705*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6](-,:[#8])-,:[#6]",
	/*706*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6](=,:[#8])-,:[#6]",
	/*707*/ "[#8]=,:[#6]-,:[#6]-,:[#6]-,:[#6]-,:[#6](-,:[#7])-,:[#6]",
	/*708*/ "[#6]-,:[#6](-,:[#6])-,:[#6]-,:[#6]",
	/*709*/ "[#6]-,:[#6](-,:[#6])-,:[#6]-,:[#6]-,:[#6]",
	/*710*/ "[#6]-,:[#6]-,:[#6](-,:[#6])-,:[#6]-,:[#6]",
	/*711*/ "[#6]-,:[#6](-,:[#6])(-,:[#6])-,:[#6]-,:[#6]",
	/*712*/ "[#6]-,:[#6](-,:[#6])-,:[#6](-,:[#6])-,:[#6]",

	/**
         * Section 7: Complex SMARTS patterns - These bits test for the presence 
         * of complex SMARTS patterns, regardless of count, but where 
         * bond orders and bond aromaticity are specific.
         */

	/*713*/ "[#6]c1ccc([#6])cc1",
	/*714*/ "[#6]c1ccc([#8])cc1",
	/*715*/ "[#6]c1ccc([#16])cc1",
	/*716*/ "[#6]c1ccc([#7])cc1",
	/*717*/ "[#6]c1ccc(Cl)cc1",
	/*718*/ "[#6]c1ccc(Br)cc1",
	/*719*/ "[#8]c1ccc([#8])cc1",
	/*720*/ "[#8]c1ccc([#16])cc1",
	/*721*/ "[#8]c1ccc([#7])cc1",
	/*722*/ "[#8]c1ccc(Cl)cc1",
	/*723*/ "[#8]c1ccc(Br)cc1",
	/*724*/ "[#16]c1ccc([#16])cc1",
	/*725*/ "[#16]c1ccc([#7])cc1",
	/*726*/ "[#16]c1ccc(Cl)cc1",
	/*727*/ "[#16]c1ccc(Br)cc1",
	/*728*/ "[#7]c1ccc([#7])cc1",
	/*729*/ "[#7]c1ccc(Cl)cc1",
	/*730*/ "[#7]c1ccc(Br)cc1",
	/*731*/ "Clc1ccc(Cl)cc1",
	/*732*/ "Clc1ccc(Br)cc1",
	/*733*/ "Brc1ccc(Br)cc1",
	/*734*/ "[#6]c1cc([#6])ccc1",
	/*735*/ "[#6]c1cc([#8])ccc1",
	/*736*/ "[#6]c1cc([#16])ccc1",
	/*737*/ "[#6]c1cc([#7])ccc1",
	/*738*/ "[#6]c1cc(Cl)ccc1",
	/*739*/ "[#6]c1cc(Br)ccc1",
	/*740*/ "[#8]c1cc([#8])ccc1",
	/*741*/ "[#8]c1cc([#16])ccc1",
	/*742*/ "[#8]c1cc([#7])ccc1",
	/*743*/ "[#8]c1cc(Cl)ccc1",
	/*744*/ "[#8]c1cc(Br)ccc1",
	/*745*/ "[#16]c1cc([#16])ccc1",
	/*746*/ "[#16]c1cc([#7])ccc1",
	/*747*/ "[#16]c1cc(Cl)ccc1",
	/*748*/ "[#16]c1cc(Br)ccc1",
	/*749*/ "[#7]c1cc([#7])ccc1",
	/*750*/ "[#7]c1cc(Cl)ccc1",
	/*751*/ "[#7]c1cc(Br)ccc1",
	/*752*/ "Clc1cc(Cl)ccc1",
	/*753*/ "Clc1cc(Br)ccc1",
	/*754*/ "Brc1cc(Br)ccc1",
	/*755*/ "[#6]c1c([#6])cccc1",
	/*756*/ "[#6]c1c([#8])cccc1",
	/*757*/ "[#6]c1c([#16])cccc1",
	/*758*/ "[#6]c1c([#7])cccc1",
	/*759*/ "[#6]c1c(Cl)cccc1",
	/*760*/ "[#6]c1c(Br)cccc1",
	/*761*/ "[#8]c1c([#8])cccc1",
	/*762*/ "[#8]c1c([#16])cccc1",
	/*763*/ "[#8]c1c([#7])cccc1",
	/*764*/ "[#8]c1c(Cl)cccc1",
	/*765*/ "[#8]c1c(Br)cccc1",
	/*766*/ "[#16]c1c([#16])cccc1",
	/*767*/ "[#16]c1c([#7])cccc1",
	/*768*/ "[#16]c1c(Cl)cccc1",
	/*769*/ "[#16]c1c(Br)cccc1",
	/*770*/ "[#7]c1c([#7])cccc1",
	/*771*/ "[#7]c1c(Cl)cccc1",
	/*772*/ "[#7]c1c(Br)cccc1",
	/*773*/ "Clc1c(Cl)cccc1",
	/*774*/ "Clc1c(Br)cccc1",
	/*775*/ "Brc1c(Br)cccc1",
	/*776*/ "[#6][#6]1[#6][#6][#6]([#6])[#6][#6]1",
	/*777*/ "[#6][#6]1[#6][#6][#6]([#8])[#6][#6]1",
	/*778*/ "[#6][#6]1[#6][#6][#6]([#16])[#6][#6]1",
	/*779*/ "[#6][#6]1[#6][#6][#6]([#7])[#6][#6]1",
	/*780*/ "[#6][#6]1[#6][#6][#6](Cl)[#6][#6]1",
	/*781*/ "[#6][#6]1[#6][#6][#6](Br)[#6][#6]1",
	/*782*/ "[#8][#6]1[#6][#6][#6]([#8])[#6][#6]1",
	/*783*/ "[#8][#6]1[#6][#6][#6]([#16])[#6][#6]1",
	/*784*/ "[#8][#6]1[#6][#6][#6]([#7])[#6][#6]1",
	/*785*/ "[#8][#6]1[#6][#6][#6](Cl)[#6][#6]1",
	/*786*/ "[#8][#6]1[#6][#6][#6](Br)[#6][#6]1",
	/*787*/ "[#16][#6]1[#6][#6][#6]([#16])[#6][#6]1",
	/*788*/ "[#16][#6]1[#6][#6][#6]([#7])[#6][#6]1",
	/*789*/ "[#16][#6]1[#6][#6][#6](Cl)[#6][#6]1",
	/*790*/ "[#16][#6]1[#6][#6][#6](Br)[#6][#6]1",
	/*791*/ "[#7][#6]1[#6][#6][#6]([#7])[#6][#6]1",
	/*792*/ "[#7][#6]1[#6][#6][#6](Cl)[#6][#6]1",
	/*793*/ "[#7][#6]1[#6][#6][#6](Br)[#6][#6]1",
	/*794*/ "Cl[#6]1[#6][#6][#6](Cl)[#6][#6]1",
	/*795*/ "Cl[#6]1[#6][#6][#6](Br)[#6][#6]1",
	/*796*/ "Br[#6]1[#6][#6][#6](Br)[#6][#6]1",
	/*797*/ "[#6][#6]1[#6][#6]([#6])[#6][#6][#6]1",
	/*798*/ "[#6][#6]1[#6][#6]([#8])[#6][#6][#6]1",
	/*799*/ "[#6][#6]1[#6][#6]([#16])[#6][#6][#6]1",
	/*800*/ "[#6][#6]1[#6][#6]([#7])[#6][#6][#6]1",
	/*801*/ "[#6][#6]1[#6][#6](Cl)[#6][#6][#6]1",
	/*802*/ "[#6][#6]1[#6][#6](Br)[#6][#6][#6]1",
	/*803*/ "[#8][#6]1[#6][#6]([#8])[#6][#6][#6]1",
	/*804*/ "[#8][#6]1[#6][#6]([#16])[#6][#6][#6]1",
	/*805*/ "[#8][#6]1[#6][#6]([#7])[#6][#6][#6]1",
	/*806*/ "[#8][#6]1[#6][#6](Cl)[#6][#6][#6]1",
	/*807*/ "[#8][#6]1[#6][#6](Br)[#6][#6][#6]1",
	/*808*/ "[#16][#6]1[#6][#6]([#16])[#6][#6][#6]1",
	/*809*/ "[#16][#6]1[#6][#6]([#7])[#6][#6][#6]1",
	/*810*/ "[#16][#6]1[#6][#6](Cl)[#6][#6][#6]1",
	/*811*/ "[#16][#6]1[#6][#6](Br)[#6][#6][#6]1",
	/*812*/ "[#7][#6]1[#6][#6]([#7])[#6][#6][#6]1",
	/*813*/ "[#7][#6]1[#6][#6](Cl)[#6][#6][#6]1",
	/*814*/ "[#7][#6]1[#6][#6](Br)[#6][#6][#6]1",
	/*815*/ "Cl[#6]1[#6][#6](Cl)[#6][#6][#6]1",
	/*816*/ "Cl[#6]1[#6][#6](Br)[#6][#6][#6]1",
	/*817*/ "Br[#6]1[#6][#6](Br)[#6][#6][#6]1",
	/*818*/ "[#6][#6]1[#6]([#6])[#6][#6][#6][#6]1",
	/*819*/ "[#6][#6]1[#6]([#8])[#6][#6][#6][#6]1",
	/*820*/ "[#6][#6]1[#6]([#16])[#6][#6][#6][#6]1",
	/*821*/ "[#6][#6]1[#6]([#7])[#6][#6][#6][#6]1",
	/*822*/ "[#6][#6]1[#6](Cl)[#6][#6][#6][#6]1",
	/*823*/ "[#6][#6]1[#6](Br)[#6][#6][#6][#6]1",
	/*824*/ "[#8][#6]1[#6]([#8])[#6][#6][#6][#6]1",
	/*825*/ "[#8][#6]1[#6]([#16])[#6][#6][#6][#6]1",
	/*826*/ "[#8][#6]1[#6]([#7])[#6][#6][#6][#6]1",
	/*827*/ "[#8][#6]1[#6](Cl)[#6][#6][#6][#6]1",
	/*828*/ "[#8][#6]1[#6](Br)[#6][#6][#6][#6]1",
	/*829*/ "[#16][#6]1[#6]([#16])[#6][#6][#6][#6]1",
	/*830*/ "[#16][#6]1[#6]([#7])[#6][#6][#6][#6]1",
	/*831*/ "[#16][#6]1[#6](Cl)[#6][#6][#6][#6]1",
	/*832*/ "[#16][#6]1[#6](Br)[#6][#6][#6][#6]1",
	/*833*/ "[#7][#6]1[#6]([#7])[#6][#6][#6][#6]1",
	/*834*/ "[#7][#6]1[#6](Cl)[#6][#6][#6][#6]1",
	/*835*/ "[#7][#6]1[#6](Br)[#6][#6][#6][#6]1",
	/*836*/ "Cl[#6]1[#6](Cl)[#6][#6][#6][#6]1",
	/*837*/ "Cl[#6]1[#6](Br)[#6][#6][#6][#6]1",
	/*838*/ "Br[#6]1[#6](Br)[#6][#6][#6][#6]1",
	/*839*/ "[#6][#6]1[#6][#6]([#6])[#6][#6]1",
	/*840*/ "[#6][#6]1[#6][#6]([#8])[#6][#6]1",
	/*841*/ "[#6][#6]1[#6][#6]([#16])[#6][#6]1",
	/*842*/ "[#6][#6]1[#6][#6]([#7])[#6][#6]1",
	/*843*/ "[#6][#6]1[#6][#6](Cl)[#6][#6]1",
	/*844*/ "[#6][#6]1[#6][#6](Br)[#6][#6]1",
	/*845*/ "[#8][#6]1[#6][#6]([#8])[#6][#6]1",
	/*846*/ "[#8][#6]1[#6][#6]([#16])[#6][#6]1",
	/*847*/ "[#8][#6]1[#6][#6]([#7])[#6][#6]1",
	/*848*/ "[#8][#6]1[#6][#6](Cl)[#6][#6]1",
	/*849*/ "[#8][#6]1[#6][#6](Br)[#6][#6]1",
	/*850*/ "[#16][#6]1[#6][#6]([#16])[#6][#6]1",
	/*851*/ "[#16][#6]1[#6][#6]([#7])[#6][#6]1",
	/*852*/ "[#16][#6]1[#6][#6](Cl)[#6][#6]1",
	/*853*/ "[#16][#6]1[#6][#6](Br)[#6][#6]1",
	/*854*/ "[#7][#6]1[#6][#6]([#7])[#6][#6]1",
	/*855*/ "[#7][#6]1[#6][#6](Cl)[#6][#6]1",
	/*856*/ "[#7][#6]1[#6][#6](Br)[#6][#6]1",
	/*857*/ "Cl[#6]1[#6][#6](Cl)[#6][#6]1",
	/*858*/ "Cl[#6]1[#6][#6](Br)[#6][#6]1",
	/*859*/ "Br[#6]1[#6][#6](Br)[#6][#6]1",
	/*860*/ "[#6][#6]1[#6]([#6])[#6][#6][#6]1",
	/*861*/ "[#6][#6]1[#6]([#8])[#6][#6][#6]1",
	/*862*/ "[#6][#6]1[#6]([#16])[#6][#6][#6]1",
	/*863*/ "[#6][#6]1[#6]([#7])[#6][#6][#6]1",
	/*864*/ "[#6][#6]1[#6](Cl)[#6][#6][#6]1",
	/*865*/ "[#6][#6]1[#6](Br)[#6][#6][#6]1",
	/*866*/ "[#8][#6]1[#6]([#8])[#6][#6][#6]1",
	/*867*/ "[#8][#6]1[#6]([#16])[#6][#6][#6]1",
	/*868*/ "[#8][#6]1[#6]([#7])[#6][#6][#6]1",
	/*869*/ "[#8][#6]1[#6](Cl)[#6][#6][#6]1",
	/*870*/ "[#8][#6]1[#6](Br)[#6][#6][#6]1",
	/*871*/ "[#16][#6]1[#6]([#16])[#6][#6][#6]1",
	/*872*/ "[#16][#6]1[#6]([#7])[#6][#6][#6]1",
	/*873*/ "[#16][#6]1[#6](Cl)[#6][#6][#6]1",
	/*874*/ "[#16][#6]1[#6](Br)[#6][#6][#6]1",
	/*875*/ "[#7][#6]1[#6]([#7])[#6][#6][#6]1",
	/*876*/ "[#7][#6]1[#6](Cl)[#6][#6]1",
	/*877*/ "[#7][#6]1[#6](Br)[#6][#6][#6]1",
	/*878*/ "Cl[#6]1[#6](Cl)[#6][#6][#6]1",
	/*879*/ "Cl[#6]1[#6](Br)[#6][#6][#6]1",
	/*880*/ "Br[#6]1[#6](Br)[#6][#6][#6]1",
    };

    // number of bits in this fingerprint
    public static final int FP_SIZE = 881;
    private static final int DIM = 16; 

    private int[] m_elements = new int[256];
    private MolAtom[] m_atoms;
    private MolBond[] m_bonds;
    private Molecule m_mol;
    private int[][] m_btab;

    private RingPerception m_ring; 
    private volatile byte[] m_bits = new byte[(FP_SIZE+7)>>3];
    private Map<Object, Molecule> m_patterns = 
        new HashMap<Object, Molecule>();
    private SearchParams m_params = SearchParams.superstructure();

    public PCFP () {
        super (1, DIM);
        initPatterns ();
    }
    public PCFP (Molecule mol) {
        this ();
        setMolecule (mol);
    }

    @Override
    public Molecule getMol (Object key) {
        return m_patterns.get(key);
    }

    protected void initPatterns () {
        MolHandler mh = new MolHandler ();
        mh.setQueryMode(true);
        for (int i = 0; i < PATTERNS.length; ++i) {
            int key = 263+i;
            try {
                mh.setMolecule(PATTERNS[i]);
                add (key, generateFingerprint (mh.getMolecule(), getDim ()));
                m_patterns.put(key, mh.getMolecule());
            }
            catch (Exception ex) {
                throw new IllegalStateException
                    ("Unable to initialize fingerprint patterns!");
            }
        }

        // don't aromatize when screening as we've already do it here
        //  already!
        m_params.setAromatize(false);
        m_params.setMinDensity(0.); // don't check for min density
    }

    public void setMolecule (Molecule mol) {
        this.m_mol = mol.cloneMolecule();
        m_mol.aromatize(Molecule.AROM_BASIC);
        m_mol.hydrogenize(true);

        for (int i = 0; i < m_elements.length; ++i) 
            m_elements[i] = 0;

        m_atoms = m_mol.getAtomArray();
        for (int i = 0; i < m_atoms.length; ++i) {
            ++m_elements[m_atoms[i].getAtno()];
        }

        m_bonds = m_mol.getBondArray();
        m_btab = m_mol.getBtab();

        for (int i = 0; i < m_bits.length; ++i)
            m_bits[i] = 0;
        
        /*
         * ring perception
         */
        m_ring = new RingPerception (m_mol, 10);

        /*
         * generate the fingerprint
         */
        generate ();

        /*
         * post processing adjustments
         */
        postprocessing ();
    }
    public Molecule getMolecule () { return m_mol; }


    private void generate () {
        int bit = countElements (0, m_bits);
	bit = countRings (bit, m_bits);
        // now count substructures
        search (m_mol, m_params, this);       
    }

    private void postprocessing () {
        /**
         * section 5
         */
        for (MolAtom a : m_atoms) {
            if (a.getAtno() == 16) {
                int nO = 0, nC = 0;
                for (int i = 0; i < a.getBondCount(); ++i) {
                    MolBond b = a.getBond(i);
                    MolAtom xa = b.getOtherAtom(a);
                    if (b.getType() != 2) ;
                    else if (xa.getAtno() == 8) ++nO;
                    else if (xa.getAtno() == 6) ++nC;
                }

                if (nC == 1 && nO == 1) {
                    set (457);
                }
                else if (nO == 2) {
                    /* 
                     * bit 458: S(-O)(=O)
                     */
                    set (458);
                }
            }
            else if (a.getAtno() == 6) {
                int nO = 0, nN = 0, nC = 0;
                for (int i = 0; i < a.getBondCount(); ++i) {
                    MolBond b = a.getBond(i);
                    MolAtom xa = b.getOtherAtom(a);
                    if (b.getType() != 2) ;
                    else if (xa.getAtno() == 7) ++nN;
                    else if (xa.getAtno() == 8) ++nO;
                    else if (xa.getAtno() == 6) ++nC;
                }

                if (nN == 2) {
                    /*
                     * bit 450: C(-N)(=N)
                     */
                    set (450);
                }
                else if (nO == 1 && nN == 1) {
                    /*
                     * bit 451: C(-N)(=O)
                     */
                    set (451);
                }
                else if (nO == 2) {
                    /*
                     * bit 452: C(-O)(=O)
                     */
                    set (452);
                }
                else if (nC == 1 && nN == 1) {
                    /*
                     * bit 442: C(-C)(=N)
                     * bit 449: C(-N)(=C)
                     */
                    set (442);
                    set (449);
                }
            }
            else if (a.getAtno() == 7) {
                int nO = 0, nN = 0, nC = 0;
                for (int i = 0; i < a.getBondCount(); ++i) {
                    MolBond b = a.getBond(i);
                    MolAtom xa = b.getOtherAtom(a);
                    if (b.getType() != 2);
                    else if (xa.getAtno() == 7) ++nN;
                    else if (xa.getAtno() == 8) ++nO;
                    else if (xa.getAtno() == 6) ++nC;
                }
                
                if (nC == 2) {
                    /*
                     * bit 453: N(-C)(=C)
                     */
                    set (453);
                }
                else if (nC == 1 && nO == 1) {
                    /*
                     * bit 454: N(-C)(=O)
                     */
                    set (454);
                }
                else if (nO == 2) {
                    /*
                     * bit 455: N(-O)(=O)
                     */
                    set (455);
                }
            }
            else if (a.getAtno() == 15) {
                int nO = 0;
                for (int i = 0; i < a.getBondCount(); ++i) {
                    MolBond b = a.getBond(i);
                    MolAtom xa = b.getOtherAtom(a);
                    if (b.getType() != 2);
                    else if (xa.getAtno() == 8) ++nO;
                }

                if (nO == 2) {
                    /*
                     * bit 456: P(-O)(=O)
                     */
                    set (456);
                }
            }
        }

        /**
         * section 6
         */
    }

    public boolean get (int bit) {
	return (m_bits[bit>>3] & MASK[bit%8]) != 0;
    }

    protected void set (int bit) {
        m_bits[bit>>3] |= MASK[bit%8];
    }

    protected void clear (int bit) {
        m_bits[bit>>3] &=~ MASK[bit%8];
    }

    public BitSet toBits () {
        BitSet bits = new BitSet (FP_SIZE);
        for (int i = 0; i < FP_SIZE; ++i) {
            bits.set(i, get (i));
        }
        return bits;
    }

    public byte[] toBytes () { return m_bits; }
    public int[] toInts () {
        int[] ifp = new int[(FP_SIZE+31)/32];
        for (int i = 0; i < m_bits.length; i += 4) {
            ifp[i/4] = ((m_bits[i] & 0xff) << 24)
                | ((m_bits[i+1] & 0xff) << 16)
                | ((m_bits[i+2] & 0xff) << 8)
                | (m_bits[i+3] & 0xff);
        }
        return ifp;
    }

    public int getCount (int atno) { return m_elements[atno]; }
    public int getCount (String symb) { 
        return m_elements[MolAtom.numOf(symb)]; 
    }

    public int countAnyRing (int size) {
        int c = 0;
        for (RingPerception.Ring r : m_ring.getRings()) {
            if (r.size() == size)
                ++c;
        }
        return c;
    }

    private boolean isCarbonOnlyRing (int[] atoms) {
        for (int i = 0; i < atoms.length; ++i) {
            if (m_atoms[atoms[i]].getAtno() != 6)
                return false;
        }
        return true;
    }

    private boolean isCarbonOnlyRing (RingPerception.Ring r) {
        for (MolAtom a : r.getAtomArray()) {
            if (a.getAtno() != 6) 
                return false;
        }
        return true;
    }

    private boolean isRingSaturated (int[] atoms) {
        for (int i = 0; i < atoms.length; ++i) {
            for (int j = i+1; j < atoms.length; ++j) {
                int b = m_btab[atoms[i]][atoms[j]];
                if (b >= 0 //&& m_mol.isRingBond(b) 
                    && m_mol.getBond(b).getType() == 2) {
                    return false;
                }
            }
        }

        return true;
    }

    private boolean isRingSaturated (RingPerception.Ring r) {
        for (MolBond b : r.getBondArray()) 
            if (b.getType() == 2)
                return false;
        return true;
    }

    /*
     * Adopt saturated and unsaturated defs from here
     * http://en.wikipedia.org/wiki/Heterocyclic_compound
     */
    private boolean isRingUnsaturated (int[] atoms) {
        int db = 0, hetero = 0, nitro = 0;
        for (int i = 0; i < atoms.length; ++i) {
            for (int j = i+1; j < atoms.length; ++j) {
                int b = m_btab[atoms[i]][atoms[j]];
                if (b >= 0 //&& m_mol.isRingBond(b) 
                    && m_mol.getBond(b).getType() == 2
                    // only count this double bond if it's not shared
                    //  with any other rings
                    && (m_ring.getRingCount(atoms[i])
                        +m_ring.getRingCount(atoms[j]) < 4)) {
                    ++db;
                }
            }

            int atno = m_atoms[atoms[i]].getAtno();
            if (atno != 6 && atno != 1) {
                if (atno == 7)
                    ++nitro;
                ++hetero;
            }
        }

        if ((db == 1 && atoms.length == 3)
            || (db == 2 && (atoms.length == 4 
                            || atoms.length == 5 
                            || (atoms.length == 6 && hetero == 1)))
            || (db == 3 && atoms.length == 7)
            || (db > 0 && hetero == 0))
            return true;
        return false;
    }

    private boolean isRingUnsaturated (RingPerception.Ring r) {
        int db = 0, hetero = 0, nitro = 0;
        for (MolBond b : r.getBondArray()) {
            if (b.getType() == 2) {
                // only count this double bond if it's not shared
                //  with any other rings
                ++db;
            }
        }

        for (MolAtom a : r.getAtomArray()) {
            int atno = a.getAtno();
            if (atno != 6 && atno != 1) {
                if (atno == 7)
                    ++nitro;
                ++hetero;
            }
        }
        //logger.info("db="+db+" hetero="+hetero+" "+r);

        if ((db == 1 && r.size() == 3)
            || (db == 2 && (r.size() == 4 
                            || r.size() == 5 
                            || (r.size() == 6 && hetero == 1)))
            || (db == 3 && r.size() == 7)
            || (db > 0 && hetero == 0))
            return true;
        return false;
    }

    private int countNitrogenInRing (int[] atoms) {
        int c = 0;
        for (int i = 0; i < atoms.length; ++i) {
            if (7 == m_atoms[atoms[i]].getAtno())
                ++c;
        }
        return c;
    }

    private int countNitrogenInRing (RingPerception.Ring r) {
        int c = 0;
        for (MolAtom a : r.getAtomArray()) {
            if (7 == a.getAtno())
                ++c;
        }
        return c;
    }

    private int countHeteroInRing (int[] atoms) {
        int c = 0;
        for (int i = 0; i < atoms.length; ++i) {
            int atno = m_atoms[atoms[i]].getAtno();
            if (atno != 6 && atno != 1)
                ++c;
        }
        return c;
    }

    private int countHeteroInRing (RingPerception.Ring r) {
        int c = 0;
        for (MolAtom a : r.getAtomArray()) {
            int atno = a.getAtno();
            if (atno != 6 && atno != 1)
                ++c;
        }
        return c;
    }

    private boolean isAromaticRing (int[] atoms) {
        Set<MolAtom> partOfRing = new HashSet<MolAtom> ();
        for (int i = 0; i < atoms.length; ++i) {
            partOfRing.add(m_atoms[atoms[i]]);
        }

        List<MolBond> bondsInRing = new ArrayList<MolBond>();
        for (int i = 0; i < atoms.length; ++i) {
            MolAtom a = m_atoms[atoms[i]];
            for (int j = 0; j < a.getBondCount(); ++j) {
                MolBond b = a.getBond(j);
                if (partOfRing.contains(b.getAtom1())
                    && partOfRing.contains(b.getAtom2())) {
                    bondsInRing.add(b);
                }
            }
        }

        for (Iterator<MolBond> iter = bondsInRing.iterator(); 
             iter.hasNext(); ) {
            MolBond b  = iter.next();
            switch (b.getType()) {
            case MolBond.AROMATIC:
            case MolBond.SINGLE_OR_AROMATIC:
            case MolBond.DOUBLE_OR_AROMATIC:
                break;
                
            default:
                return false;
            }
        }
	
        return true;
    }

    private boolean isAromaticRing (RingPerception.Ring r) {
        for (MolBond b : r.getBondArray()) {
            switch (b.getType()) {
            case MolBond.AROMATIC:
            case MolBond.SINGLE_OR_AROMATIC:
            case MolBond.DOUBLE_OR_AROMATIC:
                break;
            default:
                return false;
            }
        }
        return true;
    }

    public int countAromaticRing () {
        int c = 0;
        for (RingPerception.Ring r : m_ring.getRings()) {
            if (isAromaticRing (r))
                ++c;
        }
        return c;
    }

    public int countHeteroAromaticRing () {
        int c = 0;
        for (RingPerception.Ring r : m_ring.getRings()) {
            if (!isCarbonOnlyRing (r) && isAromaticRing (r))
                ++c;
        }
        return c;
    }
    
    public int countSaturatedOrAromaticCarbonOnlyRing (int size) {
        int c = 0;
        for (RingPerception.Ring r : m_ring.getRings()) {
            if (r.size() == size
                && isCarbonOnlyRing (r) 
                && (isRingSaturated (r) || isAromaticRing (r)))
                ++c;
        }
        return c;
    }
    
    public int countSaturatedOrAromaticNitrogenContainingRing (int size) {
        int c = 0;
        for (RingPerception.Ring r : m_ring.getRings()) {
            if (r.size() == size
                && (isRingSaturated (r) || isAromaticRing (r))
                && countNitrogenInRing (r) > 0
                )
                ++c;
        }
        return c;
    }

    public int countSaturatedOrAromaticHeteroContainingRing (int size) {
        int c = 0;
        for (RingPerception.Ring r : m_ring.getRings()) {
            if (r.size() == size
                && (isRingSaturated (r) || isAromaticRing (r))
                && countHeteroInRing (r) > 0
                )
                ++c;
        }
        return c;
    }

    public int countUnsaturatedCarbonOnlyRing (int size) {
        int c = 0;
        for (RingPerception.Ring r : m_ring.getRings()) {
            if (r.size() == size
                && isRingUnsaturated (r)
                && !isAromaticRing (r)
                && isCarbonOnlyRing (r))
                ++c;
        }
        return c;
    }

    public int countUnsaturatedNitrogenContainingRing (int size) {
        int c = 0;
        for (RingPerception.Ring r : m_ring.getRings()) {
            if (r.size() == size
                && isRingUnsaturated (r)
                && !isAromaticRing (r)
                && countNitrogenInRing (r) > 0
                )
                ++c;
        }
        return c;
    }
    
    public int countUnsaturatedHeteroContainingRing (int size) {
        int c = 0;
        for (RingPerception.Ring r: m_ring.getRings()) {
            if (r.size() == size
                && isRingUnsaturated (r)
                && !isAromaticRing (r)
                && countHeteroInRing (r) > 0
                )
                ++c;
        }
        return c;
    }


    public static double tanimoto (byte[] a, byte[] b) {
	//assert (a.length == b.length);
	int Nc = 0, Nb = 0, Na = 0;
	for (int i = 0; i < a.length; ++i) {
	    Nc += BITCOUNT[a[i] & b[i] & 0xff];
	    Nb += BITCOUNT[b[i] & 0xff];
	    Na += BITCOUNT[a[i] & 0xff];
	}
	return (double)Nc/(Na + Nb - Nc);
    }

    public static double dice (byte[] a, byte[] b) {
	//assert (a.length == b.length);
	int Nc = 0, Nb = 0, Na = 0;
	for (int i = 0; i < a.length; ++i) {
	    Nc += BITCOUNT[a[i] & b[i] & 0xff];
	    Nb += BITCOUNT[b[i] & 0xff];
	    Na += BITCOUNT[a[i] & 0xff];
	}
	return 2.*Nc/(Na + Nb);
    }

    public static double cosine (byte[] a, byte[] b) {
	//assert (a.length == b.length);
	int Nc = 0, Nb = 0, Na = 0;
	for (int i = 0; i < a.length; ++i) {
	    Nc += BITCOUNT[a[i] & b[i] & 0xff];
	    Nb += BITCOUNT[b[i] & 0xff];
	    Na += BITCOUNT[a[i] & 0xff];
	}
	return (double)Nc/Math.sqrt(Na * Nb);
    }

    // hamming distance
    public static int hamming (byte[] a, byte[] b) {
	//assert (a.length == b.length);
	int dist = 0;
	for (int i = 0; i < a.length; ++i) {
	    dist += BITCOUNT[(a[i] ^ b[i]) & 0xff];
	}
	return dist;
    }

    public double tanimoto (PCFP fp) {
	return tanimoto (this.m_bits, fp.m_bits);
    }
    public double dice (PCFP fp) {
	return dice (this.m_bits, fp.m_bits);
    }
    public double cosine (PCFP fp) {
	return cosine (this.m_bits, fp.m_bits);
    }
    public int hamming (PCFP fp) {
	return hamming (m_bits, fp.m_bits);
    }

    public static PCFP decode (String enc) {
	byte[] fp = Base64.decode(enc);
	if (fp.length < 4) {
	    throw new IllegalArgumentException 
		("Input is not a proper PubChem base64 encoded fingerprint");
	}

	int len = (fp[0] << 24) | (fp[1] << 16)
	    | (fp[2] << 8) | (fp[3] & 0xff);
	if (len != FP_SIZE) {
	    throw new IllegalArgumentException 
		("Input is not a proper PubChem base64 encoded fingerprint");
	}

	PCFP pc = new PCFP ();
	for (int i = 0; i < pc.m_bits.length; ++i) {
	    pc.m_bits[i] = fp[i+4];
	}
	return pc;
    }

    public static double tanimoto (String enc1, String enc2) {
	PCFP fp1 = decode (enc1), fp2 = decode (enc2);
	return fp1.tanimoto(fp2);
    }

    // the first four bytes contains the length of the fingerprint
    public String encode () {
	byte[] pack = new byte[4 + m_bits.length];

	pack[0] = (byte)((FP_SIZE & 0xffffffff) >> 24);
	pack[1] = (byte)((FP_SIZE & 0x00ffffff) >> 16);
	pack[2] = (byte)((FP_SIZE & 0x0000ffff) >>  8);
	pack[3] = (byte)(FP_SIZE & 0x000000ff);
	for (int i = 0; i < m_bits.length; ++i) {
	    pack[i+4] = m_bits[i];
	}
	return Base64.encodeBytes(pack, Base64.DONT_BREAK_LINES);
    }


    static final int BITCOUNT[] = {
        0,1,1,2,1,2,2,3,
        1,2,2,3,2,3,3,4,
        1,2,2,3,2,3,3,4,
        2,3,3,4,3,4,4,5,
        1,2,2,3,2,3,3,4,
        2,3,3,4,3,4,4,5,
        2,3,3,4,3,4,4,5,
        3,4,4,5,4,5,5,6,
        1,2,2,3,2,3,3,4,
        2,3,3,4,3,4,4,5,
        2,3,3,4,3,4,4,5,
        3,4,4,5,4,5,5,6,
        2,3,3,4,3,4,4,5,
        3,4,4,5,4,5,5,6,
        3,4,4,5,4,5,5,6,
        4,5,5,6,5,6,6,7,
        1,2,2,3,2,3,3,4,
        2,3,3,4,3,4,4,5,
        2,3,3,4,3,4,4,5,
        3,4,4,5,4,5,5,6,
        2,3,3,4,3,4,4,5,
        3,4,4,5,4,5,5,6,
        3,4,4,5,4,5,5,6,
        4,5,5,6,5,6,6,7,
        2,3,3,4,3,4,4,5,
        3,4,4,5,4,5,5,6,
        3,4,4,5,4,5,5,6,
        4,5,5,6,5,6,6,7,
        3,4,4,5,4,5,5,6,
        4,5,5,6,5,6,6,7,
        4,5,5,6,5,6,6,7,
        5,6,6,7,6,7,7,8
    };

    static final int MASK[] = {
	0x80,
	0x40,
	0x20,
	0x10,
	0x08,
	0x04,
	0x02,
	0x01
    };

    /*
      Section 1: Hierarchic Element Counts - These bs test for the 
      presence or count of individual chemical atoms represented 
      by their atomic symbol.
    */
    private int countElements (int b, byte[] fp) {
             if (getCount("H") >= 4 ) fp[b>>3] |= MASK[b%8];
 	++b; if (getCount("H") >= 8) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("H") >= 16) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("H") >= 32) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Li") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Li") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("B") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("B") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("B") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("C") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("C") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("C") >= 8) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("C") >= 16) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("C") >= 32) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("N") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("N") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("N") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("N") >= 8) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("O") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("O") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("O") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("O") >= 8) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("O") >= 16) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("F") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("F") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("F") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Na") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Na") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Si") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Si") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("P") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("P") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("P") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("S") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("S") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("S") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("S") >= 8) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Cl") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Cl") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Cl") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Cl") >= 8) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("K") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("K") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Br") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Br") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Br") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("I") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("I") >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("I") >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Be")	>= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Mg") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Al") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ca") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Sc") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ti") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("V") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Cr") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Mn") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Fe") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Co") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ni") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Cu") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Zn") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ga") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ge") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("As") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Se") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Kr") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Rb") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Sr") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Y") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Zr") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Nb") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Mo") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ru") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Rh") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Pd") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ag") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Cd") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("In") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Sn") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Sb") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Te") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Xe") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Cs") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ba") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Lu") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Hf") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ta") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("W") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Re") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Os") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ir") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Pt") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Au") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Hg") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Tl") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Pb") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Bi") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("La") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ce") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Pr") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Nd") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Pm") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Sm") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Eu") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Gd") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Tb") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Dy") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Ho") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Er") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Tm") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Yb") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("Tc") >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (getCount("U") >= 1) fp[b>>3] |= MASK[b%8];
        
        return b;
    }

    /**
     * Section 2: Rings in a canonic ESSR ring set-These bs test for the 
     * presence or count of the described chemical ring system.  
     * An ESSR ring is any ring which does not share three 
     * consecutive atoms with any other ring in the chemical 
     * structure.  For example, naphthalene has three ESSR rings 
     * (two phenyl fragments and the 10-membered envelope), while 
     * biphenyl will yield a count of only two ESSR rings.
     */
    private int countRings (int b, byte[] fp) {
	++b; if (countAnyRing(3) >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(3) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(3) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(3) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(3) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(3) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(3) >= 1) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(3) >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(3) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(3) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(3) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(3) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(3) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(3) >= 2) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(4) >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(4) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(4) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(4) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(4) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(4) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(4) >= 1) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(4) >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(4) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(4) >= 2)  fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(4) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(4) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(4) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(4) >= 2) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(5) >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(5) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(5) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(5) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(5) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(5) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(5) >= 1) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(5) >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(5) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(5) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(5) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(5) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(5) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(5) >= 2) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(5) >= 3) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(5) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(5) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(5) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(5) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(5) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(5) >= 3) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(5) >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(5) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(5) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(5) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(5) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(5) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(5) >= 4) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(5) >= 5) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(5) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(5) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(5) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(5) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(5) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(5) >= 5) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(6) >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(6) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(6) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(6) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(6) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(6) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(6) >= 1) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(6) >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(6) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(6) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(6) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(6) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(6) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(6) >= 2) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(6) >= 3) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(6) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(6) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(6) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(6) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(6) >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(6) >= 3) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(6) >= 4) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(6) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(6) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(6) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(6) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(6) >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(6) >= 4) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(6) >= 5) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(6) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(6) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(6) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(6) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(6) >= 5) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(6) >= 5) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(7) >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(7) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(7) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(7) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(7) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(7) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(7) >= 1) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(7) >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(7) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(7) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(7) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(7) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(7) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(7) >= 2) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(8) >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(8) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(8) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(8) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(8) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(8) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(8) >= 1) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(8) >= 2) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(8) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(8) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(8) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(8) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(8) >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(8) >= 2) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(9) >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(9) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(9) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(9) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(9) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(9) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(9) >= 1) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAnyRing(10) >= 1) fp[b>>3] |= MASK[b%8];
	++b; if (countSaturatedOrAromaticCarbonOnlyRing(10) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticNitrogenContainingRing(10) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countSaturatedOrAromaticHeteroContainingRing(10) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedCarbonOnlyRing(10) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedNitrogenContainingRing(10) >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countUnsaturatedHeteroContainingRing(10) >= 1) fp[b>>3] |= MASK[b%8]; 
        ++b; if (countAromaticRing() >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countHeteroAromaticRing() >= 1) fp[b>>3] |= MASK[b%8]; 
	++b; if (countAromaticRing() >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countHeteroAromaticRing() >= 2) fp[b>>3] |= MASK[b%8]; 
	++b; if (countAromaticRing() >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countHeteroAromaticRing() >= 3) fp[b>>3] |= MASK[b%8]; 
	++b; if (countAromaticRing() >= 4) fp[b>>3] |= MASK[b%8]; 
	++b; if (countHeteroAromaticRing() >= 4) fp[b>>3] |= MASK[b%8]; 

        return b;
    }

    /**
     * SearchCallback interface
     */
    synchronized public boolean matched (MolEntry entry) {
        Integer bit = (Integer)entry.getKey(); // matching bit
        m_bits[bit>>3] |= MASK[bit % 8];
        return true;
    }

    static void debug (String mol) throws Exception {
        MolHandler mh = new MolHandler (mol);

        long start = System.currentTimeMillis();
        PCFP pcfp = new PCFP (mh.getMolecule());
        long end = System.currentTimeMillis();

        for (RingPerception.Ring r : pcfp.m_ring.getRings()) {
            System.out.print(">> "+r.size()+" "+r.getAtomSet());
            System.out.println(" => saturated="+pcfp.isRingSaturated(r)
                               +" aromatic="+pcfp.isAromaticRing(r)
                               +" hetero="+pcfp.countHeteroInRing(r));
        }

        System.out.println(pcfp.getMolecule().getName()+" "+pcfp.toBits());
        System.out.println("** time = "+(end-start)+"ms");
    }

    public static void main (String[] argv) throws Exception {
        //debug ("CC(C)C1OC(=O)C=C2C13OC3C4OC(=O)C5(C)CCCC2(C)C45");
        //debug ("[H]N1c2c([H])c([H])c([H])c([H])c2C34C1=C(C(=O)OC([H])([H])[H])C5([H])C([H])([H])C([H])([H])N(C([H])([H])C3([H])[H])C4([H])C5([H])C([H])([H])C([H])([H])[H]");
        //debug ("CCC1C2N3CCC24C5=CC=CC=C5NC4=C(C1CC3)C(=O)OC");
        //debug ("CC(=O)OCC1=C2C(CC(C)(O)C3(O)CCC(C)(O3)C=C2OC1=O)OC(=O)C(C)=C");
        for (String a : argv) {
            debug (a);
        }
    }
}
